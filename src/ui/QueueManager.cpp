#include "QueueManager.h"

QM::QueueManager::QueueManager(wxEvtHandler* eventHandler, const wxString& jobsdir) {
    // need to send events into the mainwindow by the threads...
    this->eventHandler = eventHandler;
    this->eventHandler->Bind(wxEVT_THREAD, &QueueManager::OnThreadMessage, this);
    this->jobsDir   = jobsdir;
    this->QueueList = {};
    this->LoadJobListFromDir();
}

QM::QueueManager::~QueueManager() {
    if (this->currentItem) {
        this->currentItem = nullptr;
    }
}

uint64_t QM::QueueManager::AddItem(const QueueItem& _item, bool fromFile) {
    std::lock_guard<std::mutex> lock(queueMutex);
    std::shared_ptr<QueueItem> item = std::make_shared<QueueItem>(_item);

    if (item->server.empty() == false) {
        size_t tmpid                 = this->RemoteQueueList.size();
        this->RemoteQueueList[tmpid] = item;
        this->SendEventToMainWindow(QueueEvents::ITEM_ADDED, item);
        return 0;
    }
    if (item->id == 0) {
        item->id = this->GetAnId();
    }
    if (item->created_at == 0) {
        item->created_at = this->GetCurrentUnixTimestamp();
    }
    if (item->id == this->lastExtId) {
        std::cerr << "ID collision: " << item->id << std::endl;
        return 0;
    }

    this->lastExtId = item->id;

    this->QueueList[item->id] = item;

    if (fromFile == false) {
        this->SaveJobToFile(*item);
    }

    this->SendEventToMainWindow(QueueEvents::ITEM_ADDED, item);

    if (this->isRunning == false && item->status == QueueStatus::PENDING) {
        this->currentItem = item;
        this->SendEventToMainWindow(QueueEvents::ITEM_START, item);
        this->isRunning = true;
    }

    return item->id;
}
void QM::QueueManager::UpdateItem(const QueueItem& item) {
    std::lock_guard<std::mutex> lock(queueMutex);
    if (this->QueueList.find(item.id) != this->QueueList.end()) {
        *this->QueueList[item.id] = item;
        this->SaveJobToFile(item);
    }
}

void QM::QueueManager::UpdateItem(std::shared_ptr<QueueItem> item) {
    std::lock_guard<std::mutex> lock(queueMutex);
    if (this->QueueList.find(item->id) != this->QueueList.end()) {
        this->QueueList[item->id] = item;
        this->SaveJobToFile(*item);
    }
}

std::shared_ptr<QueueItem> QM::QueueManager::GetItemPtr(uint64_t id) {
    std::lock_guard<std::mutex> lock(queueMutex);
    if (this->QueueList.find(id) == this->QueueList.end()) {
        return nullptr;
    } else {
        return this->QueueList[id];
    }
}

std::shared_ptr<QueueItem> QM::QueueManager::GetItemPtr(const QueueItem& item) {
    return this->GetItemPtr(item.id);
}

const std::map<int, std::shared_ptr<QueueItem>> QM::QueueManager::getList() {
    std::lock_guard<std::mutex> lock(queueMutex);
    std::map<int, std::shared_ptr<QueueItem>> newlist;
    for (auto item : this->QueueList) {
        newlist[item.first] = item.second;
    }
    return newlist;
}

std::shared_ptr<QueueItem> QM::QueueManager::Duplicate(std::shared_ptr<QueueItem> item) {
    if (this->QueueList.find(item->id) == this->QueueList.end()) {
        return nullptr;
    }

    std::shared_ptr<QueueItem> newitem = std::make_shared<QueueItem>(*item);
    // handle this in the AddItem
    newitem->id             = 0;
    newitem->created_at     = 0;
    newitem->updated_at     = 0;
    newitem->started_at     = 0;
    newitem->finished_at    = 0;
    newitem->status         = QueueStatus::PENDING;
    newitem->status_message = "";
    newitem->stats          = QueueItemStats();
    newitem->steps          = 0;
    newitem->step           = 0;
    newitem->time           = 0;

    // remove old images whitch are generated by the original job
    if (newitem->mode == SDMode::TXT2IMG ||
        newitem->mode == SDMode::IMG2IMG ||
        newitem->mode == SDMode::UPSCALE) {
        newitem->images.erase(
            std::remove_if(newitem->images.begin(), newitem->images.end(),
                           [](QueueItemImage img) {
                               return sd_gui_utils::networks::hasImageType(img.type, sd_gui_utils::networks::ImageType::GENERATED);
                           }),
            newitem->images.end());
    }

    newitem->rawImages.clear();
    // re create images

    std::vector<QueueItemImage> tmpList;

    for (auto it = newitem->images.begin(); it != newitem->images.end(); it++) {
        tmpList.push_back((*it));
    }
    newitem->images.clear();
    for (auto it = tmpList.begin(); it != tmpList.end(); it++) {
        newitem->images.push_back((*it));
    }
    tmpList.clear();

    // set to paused, user will start manually
    newitem->status = QueueStatus::PAUSED;
    this->AddItem(newitem);
    return newitem;
}
uint64_t QM::QueueManager::AddItem(std::shared_ptr<QueueItem> item, bool fromFile) {
    return this->AddItem(*item, fromFile);
}

std::shared_ptr<QueueItem> QM::QueueManager::Duplicate(uint64_t id) {
    if (this->QueueList.find(id) != this->QueueList.end()) {
        return this->Duplicate(this->QueueList[id]);
    }
    return nullptr;
}

void QM::QueueManager::SetStatus(QueueStatus status, std::shared_ptr<QueueItem> item) {
    if (this->QueueList.find(item->id) != this->QueueList.end()) {
        if (item->finished_at == 0 && status == QueueStatus::DONE) {
            item->finished_at = this->GetCurrentUnixTimestamp();
        } else {
            item->updated_at = this->GetCurrentUnixTimestamp();
        }
        this->QueueList[item->id]->status = status;
        this->SaveJobToFile(*this->QueueList[item->id]);
        this->SendEventToMainWindow(QueueEvents::ITEM_STATUS_CHANGED, this->QueueList[item->id]);
    }
}

void QM::QueueManager::PauseAll() {
    for (auto q : this->QueueList) {
        if (q.second->status == QueueStatus::PENDING) {
            this->SetStatus(QueueStatus::PAUSED, q.second);
        }
    }
}

void QM::QueueManager::RestartQueue() {
    for (auto q : this->QueueList) {
        if (q.second->status == QueueStatus::PAUSED) {
            this->SetStatus(QueueStatus::PENDING, q.second);
        }
    }

    if (!this->isRunning) {
        for (auto job : this->QueueList) {
            if (job.second->status == QueueStatus::PENDING) {
                if (this->isRunning == false) {
                    this->isRunning   = true;
                    this->currentItem = job.second;
                    this->SendEventToMainWindow(QueueEvents::ITEM_START, job.second);
                }
                break;
            }
        }
    }
}

void QM::QueueManager::UnPauseItem(std::shared_ptr<QueueItem> item) {
    if (item->status == QueueStatus::PAUSED) {
        this->SetStatus(QueueStatus::PENDING, item);
        // check if queue is active
        if (!this->isRunning) {
            this->currentItem = this->QueueList[item->id];
            this->SendEventToMainWindow(QueueEvents::ITEM_START, this->QueueList[item->id]);
            this->isRunning = true;
        }
    }
}

void QM::QueueManager::PauseItem(std::shared_ptr<QueueItem> item) {
    if (item->status == QueueStatus::PENDING) {
        this->SetStatus(QueueStatus::PAUSED, item);
    }
}

void QM::QueueManager::SendEventToMainWindow(QueueEvents eventType, std::shared_ptr<QueueItem> item) {
    // TODO: e->SetInt instead of SetString
    wxThreadEvent* e = new wxThreadEvent();
    e->SetString(wxString::Format("%d:%d", (int)sd_gui_utils::ThreadEvents::QUEUE, (int)eventType));
    e->SetPayload(item);
    wxQueueEvent(this->eventHandler, e);
}

void QM::QueueManager::OnThreadMessage(wxThreadEvent& e) {
    e.Skip();

    if (e.GetId() == 9999) {
        return;
    }
    auto msg = e.GetString();

    wxString token   = msg.substr(0, msg.find(":"));
    wxString content = msg.substr(msg.find(":") + 1);

    sd_gui_utils::ThreadEvents threadEvent = (sd_gui_utils::ThreadEvents)wxAtoi(token);

    // only handle the QUEUE messages, what this class generate
    if (threadEvent == sd_gui_utils::ThreadEvents::QUEUE) {
        QueueEvents event = (QueueEvents)wxAtoi(content);
        auto payload      = e.GetPayload<std::shared_ptr<QueueItem>>();
        if (event == QueueEvents::ITEM_START) {
            this->SetStatus(QueueStatus::RUNNING, payload);
            this->isRunning   = true;
            this->currentItem = payload;
            return;
        }
        if (event == QueueEvents::ITEM_FINISHED) {
            this->SetStatus(QueueStatus::DONE, payload);
            this->isRunning   = false;
            this->currentItem = nullptr;
            // jump to the next item in queue
            // find waiting jobs
            for (auto job : this->QueueList) {
                if (job.second->status == QueueStatus::PENDING) {
                    if (this->isRunning == false) {
                        this->currentItem = job.second;
                        this->SendEventToMainWindow(QueueEvents::ITEM_START, job.second);
                        this->isRunning = true;
                    }
                    break;
                }
            }
            return;
        }
        if (event == QueueEvents::ITEM_MODEL_LOAD_START) {
            auto payload = e.GetPayload<std::shared_ptr<QueueItem>>();
            this->SetStatus(QueueStatus::MODEL_LOADING, payload);
        }
        if (event == QueueEvents::ITEM_MODEL_FAILED) {
            auto payload = e.GetPayload<std::shared_ptr<QueueItem>>();
            this->SetStatus(QueueStatus::FAILED, payload);
            this->isRunning = false;
            // jump to the next
            for (auto job : this->QueueList) {
                if (job.second->status == QueueStatus::PENDING) {
                    if (this->isRunning == false) {
                        this->currentItem = job.second;
                        this->SendEventToMainWindow(QueueEvents::ITEM_START, job.second);
                        this->isRunning = true;
                    }
                    break;
                }
            }
        }
        if (event == QueueEvents::ITEM_FAILED) {
            auto payload = e.GetPayload<std::shared_ptr<QueueItem>>();
            this->SetStatus(QueueStatus::FAILED, payload);
            this->isRunning = false;
            // jump to the next
            for (auto job : this->QueueList) {
                if (job.second->status == QueueStatus::PENDING) {
                    if (this->isRunning == false) {
                        this->currentItem = job.second;
                        this->SendEventToMainWindow(QueueEvents::ITEM_START, job.second);
                        this->isRunning = true;
                    }
                    break;
                }
            }
        }
        if (event == QueueEvents::ITEM_GENERATION_STARTED) {
            auto payload = e.GetPayload<std::shared_ptr<QueueItem>>();
            this->SetStatus(QueueStatus::RUNNING, payload);
            this->isRunning = true;
        }
    }

    if (threadEvent == sd_gui_utils::ThreadEvents::HASHING_PROGRESS) {
        auto payload = e.GetPayload<std::shared_ptr<QueueItem>>();
        this->SetStatus(QueueStatus::HASHING, payload);
    }
}

void QM::QueueManager::SaveJobToFile(uint64_t id) {
    auto item = this->GetItemPtr(id);
    this->SaveJobToFile(*item);
}

void QM::QueueManager::SaveJobToFile(const QueueItem& item) {
    try {
        nlohmann::json jsonfile(item);
        auto filename = wxFileName(wxString::Format("%s%slocal_%lu.json", this->jobsDir, wxFileName::GetPathSeparators(), item.id));
        wxFile file(filename.GetAbsolutePath(), wxFile::write);
        file.Write(jsonfile.dump());
    } catch (const std::exception& e) {
        std::cerr << e.what() << '\n';
    }
}

bool QM::QueueManager::DeleteJob(const QueueItem& item) {
    return this->DeleteJob(item.id);
}

bool QM::QueueManager::DeleteJob(uint64_t id) {
    auto item = this->GetItemPtr(id);
    if (item->id == 0) {
        return false;
    }
    auto filename = wxFileName(wxString::Format("%s%slocal_%lu.json", this->jobsDir, wxFileName::GetPathSeparators(), item->id));
    if (wxFileName::FileExists(filename.GetAbsolutePath())) {
        if (wxRemoveFile(filename.GetAbsolutePath())) {
            this->QueueList[item->id] = nullptr;
            this->QueueList.erase(item->id);
            return true;
        }
    }
    return false;
}

bool QM::QueueManager::IsRunning() {
    return this->isRunning;
}

int QM::QueueManager::GetCurrentUnixTimestamp(bool milliseconds) {
    const auto p1 = std::chrono::system_clock::now();
    auto duration = p1.time_since_epoch();

    if (milliseconds) {
        return static_cast<int>(std::chrono::duration_cast<std::chrono::milliseconds>(duration).count());
    } else {
        return static_cast<int>(std::chrono::duration_cast<std::chrono::seconds>(duration).count());
    }
}

void QM::QueueManager::LoadJobListFromDir() {
    if (!wxDirExists(this->jobsDir)) {
        wxMkdir(this->jobsDir);
        return;
    }

    wxDir dir(this->jobsDir);
    if (!dir.IsOpened()) {
        return;
    }

    std::vector<wxFileName> files;
    wxString filename;
    bool cont = dir.GetFirst(&filename, wxEmptyString, wxDIR_FILES);
    while (cont) {
        wxFileName path(this->jobsDir, filename);

        if (path.IsFileReadable() && path.HasExt() && path.GetExt() == "json") {
            files.push_back(path);
        }

        cont = dir.GetNext(&filename);
    }

    // Sort files by modification time
    std::sort(files.begin(), files.end(), [](const wxFileName& a, const wxFileName& b) {
        return a.GetModificationTime() < b.GetModificationTime();
    });

    for (const auto& path : files) {
        std::ifstream f(path.GetFullPath().ToStdString());

        try {
            nlohmann::json data                 = nlohmann::json::parse(f);
            std::shared_ptr<QueueItem> item = std::make_shared<QueueItem>(data.get<QueueItem>());
            if (item->status == QueueStatus::RUNNING ||
                item->status == QueueStatus::MODEL_LOADING ||
                item->status == QueueStatus::HASHING ||
                item->status == QueueStatus::HASHING_DONE) {
                item->status = QueueStatus::PAUSED;
            }

            this->AddItem(item, true);
        } catch (nlohmann::json::parse_error& ex) {
            std::cerr << "parse error at byte " << ex.byte << " in file: " << path.GetFullPath().ToStdString() << std::endl;
        } catch (const nlohmann::json::out_of_range& e) {
            std::cerr << "message: " << e.what() << '\n'
                      << "exception id: " << e.id << '\n'
                      << "in file: " << path.GetFullPath().ToStdString() << std::endl;
        }
    }
}

uint64_t QM::QueueManager::GetAnId() {
    uint64_t id = this->GetCurrentUnixTimestamp(false);
    while (id <= this->lastId) {
        id++;
    }
    this->lastId = id;
    return id;
}

void QM::QueueManager::onItemAdded(QueueItem item) {
    // this->parent->m_joblist
    // auto dataTable = this->parent->m_joblist;
}
