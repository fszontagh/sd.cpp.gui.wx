#ifndef __SD_GUI_QUEUE_MANAGER
#define __SD_GUI_QUEUE_MANAGER

#include <fstream>
#include <map>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <vector>

#include "utils.hpp"

#include <wx/event.h>
#include <wx/window.h>

#include "ver.hpp"
#include "wx/string.h"

namespace QM {
    enum QueueStatus {
        PENDING,
        RUNNING,
        PAUSED,
        FAILED,
        MODEL_LOADING,
        DONE,
        HASHING
    };

    enum GenerationMode {
        TXT2IMG,
        IMG2IMG,
        CONVERT,
        UPSCALE,
        IMG2VID
    };

    inline const std::unordered_map<QM::GenerationMode, std::string> GenerationMode_str = {
        {QM::GenerationMode::TXT2IMG, "txt2img"},
        {QM::GenerationMode::IMG2IMG, "img2img"},
        {QM::GenerationMode::CONVERT, "convert"},
        {QM::GenerationMode::UPSCALE, "upscale"},
        {QM::GenerationMode::IMG2VID, "img2vid"}};

    inline const std::unordered_map<std::string, QM::GenerationMode> GenerationMode_str_inv = {
        {"txt2img", QM::GenerationMode::TXT2IMG},
        {"img2img", QM::GenerationMode::IMG2IMG},
        {"convert", QM::GenerationMode::CONVERT},
        {"upscale", QM::GenerationMode::UPSCALE},
        {"img2vid", QM::GenerationMode::IMG2VID}};

    inline const char* QueueStatus_str[] = {
        "pending",
        "running",
        "paused",
        "failed",
        "model loading...",
        "finished",
        "model hashing..."};

    /// @brief Event commands to inter thread communication
    enum class QueueEvents : unsigned int {
        ITEM_DELETED            = 1 << 0,
        ITEM_ADDED              = 1 << 1,
        ITEM_STATUS_CHANGED     = 1 << 2,
        ITEM_UPDATED            = 1 << 3,
        ITEM_START              = 1 << 4,
        ITEM_FINISHED           = 1 << 5,
        ITEM_MODEL_LOAD_START   = 1 << 6,
        ITEM_MODEL_LOADED       = 1 << 7,
        ITEM_MODEL_FAILED       = 1 << 8,
        ITEM_GENERATION_STARTED = 1 << 9,
        ITEM_FAILED             = 1 << 10,
        SD_MESSAGE              = 1 << 11
    };

    enum class QueueItemImageType : unsigned int {
        /// @brief The image is generated by diffusion
        GENERATED = 1 << 0,
        /// @brief The image is added by user into the controlnet
        CONTROLNET = 1 << 1,
        /// @brief This is an itial image (eg. img2img original image, or upscaler original image)
        INITIAL = 1 << 2,
        UNKNOWN = 1 << 3
    };

    inline const std::unordered_map<unsigned int, QueueEvents> QueueEvents_str_by_ui = {
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_DELETED), QueueEvents::ITEM_DELETED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_ADDED), QueueEvents::ITEM_ADDED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_STATUS_CHANGED), QueueEvents::ITEM_STATUS_CHANGED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_UPDATED), QueueEvents::ITEM_UPDATED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_START), QueueEvents::ITEM_START},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_FINISHED), QueueEvents::ITEM_FINISHED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_MODEL_LOAD_START), QueueEvents::ITEM_MODEL_LOAD_START},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_MODEL_LOADED), QueueEvents::ITEM_MODEL_LOADED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_MODEL_FAILED), QueueEvents::ITEM_MODEL_FAILED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_GENERATION_STARTED), QueueEvents::ITEM_GENERATION_STARTED},
        {static_cast<unsigned int>(QM::QueueEvents::ITEM_FAILED), QueueEvents::ITEM_FAILED},
        {static_cast<unsigned int>(QM::QueueEvents::SD_MESSAGE), QueueEvents::SD_MESSAGE}};

    inline const std::unordered_map<QM::QueueEvents, std::string> QueueEvents_str = {
        {QM::QueueEvents::ITEM_DELETED, "ITEM_DELETED"},
        {QM::QueueEvents::ITEM_ADDED, "ITEM_ADDED"},
        {QM::QueueEvents::ITEM_STATUS_CHANGED, "ITEM_STATUS_CHANGED"},
        {QM::QueueEvents::ITEM_UPDATED, "ITEM_UPDATED"},
        {QM::QueueEvents::ITEM_START, "ITEM_START"},
        {QM::QueueEvents::ITEM_FINISHED, "ITEM_FINISHED"},
        {QM::QueueEvents::ITEM_MODEL_LOAD_START, "ITEM_MODEL_LOAD_START"},
        {QM::QueueEvents::ITEM_MODEL_LOADED, "ITEM_MODEL_LOADED"},
        {QM::QueueEvents::ITEM_MODEL_FAILED, "ITEM_MODEL_FAILED"},
        {QM::QueueEvents::ITEM_GENERATION_STARTED, "ITEM_GENERATION_STARTED"},
        {QM::QueueEvents::ITEM_FAILED, "ITEM_FAILED"},
        {QM::QueueEvents::SD_MESSAGE, "SD_MESSAGE"}};

    inline std::unordered_map<QM::QueueItemImageType, std::string> QueueItemImageType_str = {
        {QM::QueueItemImageType::GENERATED, "Generated"},
        {QM::QueueItemImageType::CONTROLNET, "Controlnet"},
        {QM::QueueItemImageType::INITIAL, "Initial"},
        {QM::QueueItemImageType::INITIAL, "Unknown"}};

    /// @brief Store the images from the queue jobs
    struct QueueItemImage {
        std::string pathname;
        QM::QueueItemImageType type = QM::QueueItemImageType::GENERATED;
        long id                     = -1;

        QueueItemImage() = default;

        QueueItemImage(const QueueItemImage* other)
            : pathname(other->pathname), type(other->type), id(other->id) {}

        QueueItemImage(const QueueItemImage& other)
            : pathname(other.pathname), type(other.type), id(other.id) {}
        QueueItemImage(const std::string& pathname_, QM::QueueItemImageType type_ = QM::QueueItemImageType::GENERATED, long id_ = -1)
            : pathname(pathname_), type(type_), id(id_) {}

        QueueItemImage(const wxString& pathname_, QM::QueueItemImageType type_ = QM::QueueItemImageType::GENERATED, long id_ = -1)
            : pathname(pathname_.utf8_string()), type(type_), id(id_) {}

        QueueItemImage& operator=(const QueueItemImage& other) {
            if (this == &other) {
                return *this;
            }

            pathname = other.pathname;
            type     = other.type;
            id       = other.id;
            return *this;
        }

        bool operator==(const QueueItemImage& other) const {
            return (pathname == other.pathname);
        }
    };
    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(QueueItemImage, pathname, type, id)
    inline void to_json(nlohmann::json& j, const QueueItemImage* item) {
        if (item) {
            j = nlohmann::json{{"pathname", sd_gui_utils::UnicodeToUTF8(item->pathname)}, {"type", item->type}};
        } else {
            j = nullptr;
        }
    }

    inline void from_json(const nlohmann::json& j, QueueItemImage*& item) {
        if (!j.is_null()) {
            item = new QueueItemImage();
            j.at("pathname").get_to(item->pathname);
            j.at("type").get_to(item->type);
        } else {
            item = nullptr;
        }
    }
    struct QueueStatsStepItem {
        int step;
        int steps;
        float time;
    };
    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(QueueStatsStepItem, step, steps, time)
    struct QueueItemStats {
        float time_min = 0.f, time_max = 0.f, time_avg = 0.f, time_total = 0.f;
        std::vector<QM::QueueStatsStepItem> time_per_step = {};
    };
    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(QueueItemStats, time_min, time_max, time_avg, time_total, time_per_step)

    struct QueueItem {
        int id = 0, created_at = 0, updated_at = 0, finished_at = 0, started_at = 0;
        SDParams params                        = SDParams();
        QM::QueueStatus status                 = QM::QueueStatus::PENDING;
        QM::QueueEvents event                  = QM::QueueEvents::ITEM_ADDED;
        QM::QueueItemStats stats               = QM::QueueItemStats();
        std::vector<QM::QueueItemImage> images = {};
        int step = 0, steps = 0;
        size_t hash_fullsize = 0, hash_progress_size = 0;
        float time                         = 0;
        std::string model                  = "";
        QM::GenerationMode mode            = QM::GenerationMode::TXT2IMG;
        std::string initial_image          = "";
        std::string status_message         = "";
        uint32_t upscale_factor            = 4;
        std::string sha256                 = "";
        std::vector<std::string> rawImages = {};
        std::string app_version            = SD_GUI_VERSION;
        std::string git_version            = GIT_HASH;
        bool keep_checkpoint_in_memory     = false;
        bool keep_upscaler_in_memory       = false;
        int update_index                   = -1;
        QueueItem(const QueueItem& other)
            : id(other.id),
              created_at(other.created_at),
              updated_at(other.updated_at),
              finished_at(other.finished_at),
              started_at(other.started_at),
              params(other.params),
              status(other.status),
              event(other.event),
              stats(other.stats),
              images(other.images),
              step(other.step),
              steps(other.steps),
              hash_fullsize(other.hash_fullsize),
              hash_progress_size(other.hash_progress_size),
              time(other.time),
              model(other.model),
              mode(other.mode),
              initial_image(other.initial_image),
              status_message(other.status_message),
              upscale_factor(other.upscale_factor),
              sha256(other.sha256),
              rawImages(other.rawImages),
              app_version(other.app_version),
              git_version(other.git_version),
              keep_checkpoint_in_memory(other.keep_checkpoint_in_memory),
              keep_upscaler_in_memory(other.keep_upscaler_in_memory),
              update_index(other.update_index) {}
        QueueItem() = default;
    };

    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(
        QueueItem,
        id,
        created_at,
        updated_at,
        finished_at,
        started_at,
        params,
        status,
        event,
        stats,
        images,
        step,
        steps,
        hash_fullsize,
        hash_progress_size,
        time,
        model,
        mode,
        initial_image,
        status_message,
        upscale_factor,
        sha256,
        rawImages,
        app_version,
        git_version,
        keep_checkpoint_in_memory,
        keep_upscaler_in_memory,
        update_index
        )

    class QueueManager {
    public:
        QueueManager(wxEvtHandler* eventHandler, std::string jobsdir);
        ~QueueManager();
        int AddItem(const QM::QueueItem& _item, bool fromFile = false);
        int AddItem(std::shared_ptr<QM::QueueItem> _item, bool fromFile = false);
        void UpdateItem(const QM::QueueItem& item);
        std::shared_ptr<QM::QueueItem> GetItemPtr(int id);
        /**
         * @brief Get all the items in the queue as a string formatted like:
         *
         */
        std::shared_ptr<QM::QueueItem> GetItemPtr(const QM::QueueItem& item);
        const std::map<int, std::shared_ptr<QM::QueueItem>> getList();
        std::shared_ptr<QM::QueueItem> Duplicate(std::shared_ptr<QM::QueueItem> item);
        std::shared_ptr<QM::QueueItem> Duplicate(int id);
        // @brief Update the item too then update the status. This will store the list of the generated images too
        void SetStatus(QM::QueueStatus status, std::shared_ptr<QM::QueueItem>);
        void PauseAll();
        void RestartQueue();
        void UnPauseItem(std::shared_ptr<QM::QueueItem> item);
        void PauseItem(std::shared_ptr<QM::QueueItem> item);
        void SendEventToMainWindow(QM::QueueEvents eventType, std::shared_ptr<QM::QueueItem> item = nullptr);
        void OnThreadMessage(wxThreadEvent& e);
        void SaveJobToFile(int id);
        void SaveJobToFile(const QM::QueueItem& item);
        bool DeleteJob(const QM::QueueItem& item);
        bool DeleteJob(int id);
        bool IsRunning();
        inline void resetRunning(std::shared_ptr<QM::QueueItem> item, const std::string& reason) {
            if (this->QueueList.empty()) {
                return;
            }
            std::lock_guard<std::mutex> lock(queueMutex);
            if (this->QueueList.find(item->id) != this->QueueList.end()) {
                item->status_message = reason;
                this->SendEventToMainWindow(QM::QueueEvents::ITEM_FAILED, this->QueueList[item->id]);
            }
        }
        inline void resetRunning(const std::string& reason) {
            if (this->QueueList.empty()) {
                return;
            }
            std::lock_guard<std::mutex> lock(queueMutex);
            if (this->currentItem == nullptr) {
                return;
            }
            if (this->QueueList.find(this->currentItem->id) != this->QueueList.end()) {
                if (reason.empty() == false) {
                    this->currentItem->status_message = reason;
                }
                this->SendEventToMainWindow(QM::QueueEvents::ITEM_FAILED, this->QueueList[this->currentItem->id]);
            }
        }
        inline std::shared_ptr<QM::QueueItem> GetCurrentItem() { return this->currentItem; }

    private:
        std::mutex queueMutex;
        int GetCurrentUnixTimestamp(bool milliseconds = false);
        void LoadJobListFromDir();
        std::string jobsDir;
        int lastId    = 0;
        int lastExtId = 0;
        int GetAnId();
        // thread events handler, toupdate main window data table
        void onItemAdded(QM::QueueItem item);
        std::shared_ptr<QM::QueueItem> currentItem = nullptr;

        // @brief check if something is running or not
        bool isRunning = false;

        wxEvtHandler* eventHandler;
        wxWindow* parent;
        std::map<int, std::shared_ptr<QM::QueueItem>> QueueList;
    };
};

#endif