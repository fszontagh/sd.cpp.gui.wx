#ifndef __SD_GUI_QUEUE_MANAGER
#define __SD_GUI_QUEUE_MANAGER

namespace QM {
    enum class QueueItemImageType : unsigned int {
        /// @brief The image is generated by diffusion
        GENERATED = 1 << 0,
        /// @brief The image is added by user into the controlnet
        CONTROLNET = 1 << 1,
        /// @brief This is an itial image (eg. img2img original image, or upscaler original image)
        INITIAL = 1 << 2,
        /// @brief The image is a mask image on img2img
        MASK = 1 << 3,
        /// @brief The image is a tmp image, deletable
        TMP = 1 << 4,
        /// @brief The original image, if in img2img the initial image is resized to outpaint
        ORIGINAL      = 1 << 5,
        MASK_OUTPAINT = 1 << 6,
        MASK_INPAINT  = 1 << 7,
        MASK_USED     = 1 << 8,
        UNKNOWN
    };
    inline QM::QueueItemImageType operator|(QM::QueueItemImageType lhs, QM::QueueItemImageType rhs) {
        return static_cast<QM::QueueItemImageType>(static_cast<unsigned int>(lhs) | static_cast<unsigned int>(rhs));
    }

    inline QM::QueueItemImageType& operator|=(QM::QueueItemImageType& lhs, QM::QueueItemImageType rhs) {
        lhs = lhs | rhs;
        return lhs;
    }
    inline bool hasType(QM::QueueItemImageType combinedType, QM::QueueItemImageType singleType) {
        return (static_cast<unsigned int>(combinedType) & static_cast<unsigned int>(singleType)) != 0;
    }

    /// @brief Store the images from the queue jobs
    struct QueueItemImage {
        std::string pathname;
        QM::QueueItemImageType type = QM::QueueItemImageType::GENERATED;
        long id                     = -1;

        QueueItemImage() = default;

        QueueItemImage(const QueueItemImage* other)
            : pathname(other->pathname), type(other->type), id(other->id) {}

        QueueItemImage(const QueueItemImage& other)
            : pathname(other.pathname), type(other.type), id(other.id) {}
        QueueItemImage(const std::string& pathname_, QM::QueueItemImageType type_ = QM::QueueItemImageType::GENERATED, long id_ = -1)
            : pathname(pathname_), type(type_), id(id_) {}

        QueueItemImage(const wxString& pathname_, QM::QueueItemImageType type_ = QM::QueueItemImageType::GENERATED, long id_ = -1)
            : pathname(pathname_.utf8_string()), type(type_), id(id_) {}

        QueueItemImage& operator=(const QueueItemImage& other) {
            if (this == &other) {
                return *this;
            }

            pathname = other.pathname;
            type     = other.type;
            id       = other.id;
            return *this;
        }

        bool operator==(const QueueItemImage& other) const {
            return (pathname == other.pathname);
        }
    };
    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(QueueItemImage, pathname, type, id)
    inline void to_json(nlohmann::json& j, const QueueItemImage* item) {
        if (item) {
            j = nlohmann::json{{"pathname", wxString(item->pathname).utf8_string()}, {"type", item->type}};
        } else {
            j = nullptr;
        }
    }

    inline void from_json(const nlohmann::json& j, QueueItemImage*& item) {
        if (!j.is_null()) {
            item = new QueueItemImage();
            j.at("pathname").get_to(item->pathname);
            j.at("type").get_to(item->type);
        } else {
            item = nullptr;
        }
    }

    struct QueueItem : public sd_gui_utils::networks::RemoteQueueItem {
        std::vector<QM::QueueItemImage> images = {};
        std::vector<std::string> rawImages     = {};
        std::string initial_image              = "";
        std::string mask_image                 = "";
        inline wxString GetActualSpeed() {
            wxString speed = "";
            if (this->status == QueueStatus::MODEL_LOADING || this->mode == SDMode::CONVERT) {
                int progress = (this->step / this->steps) * 100;
                speed        = wxString::Format(this->time > 1.0f ? "%.2fs/it" : "%.2fit/s", this->time > 1.0f || this->time == 0 ? this->time : (1.0f / this->time));
            } else {
                speed = wxString::Format(this->time > 1.0f ? "%.2fs/it %d/%d" : "%.2fit/s %d/%d", this->time > 1.0f || this->time == 0 ? this->time : (1.0f / this->time), this->step, this->steps);
            }
            return speed;
        }
        inline int GetActualProgress() {
            float current_progress = 0.f;

            if (this->step > 0 && this->steps > 0) {
                current_progress = 100.f * (static_cast<float>(this->step) /
                                            static_cast<float>(this->steps));
            }
            if (this->step == this->steps) {
                current_progress = 100.f;
            }
            return static_cast<int>(current_progress);
        }
        QueueItem(const sd_gui_utils::networks::RemoteQueueItem& item)
            : sd_gui_utils::networks::RemoteQueueItem(item) {}
        QueueItem(const QueueItem& item)
            : sd_gui_utils::networks::RemoteQueueItem(item), images(item.images), rawImages(item.rawImages), initial_image(item.initial_image), mask_image(item.mask_image) {}
        QueueItem() = default;
    };

    NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(
        QueueItem,
        id,
        created_at,
        updated_at,
        finished_at,
        started_at,
        params,
        status,
        event,
        stats,
        images,
        step,
        steps,
        hash_fullsize,
        hash_progress_size,
        time,
        model,
        mode,
        initial_image,
        mask_image,
        status_message,
        upscale_factor,
        sha256,
        rawImages,
        app_version,
        git_version,
        original_prompt,
        original_negative_prompt,
        keep_checkpoint_in_memory,
        keep_upscaler_in_memory,
        need_sha256,
        generated_sha256,
        update_index)

    class QueueManager {
    public:
        QueueManager(wxEvtHandler* eventHandler, const wxString& jobsdir);
        ~QueueManager();
        int AddItem(const QM::QueueItem& _item, bool fromFile = false);
        int AddItem(std::shared_ptr<QM::QueueItem> _item, bool fromFile = false);
        int GetNextId() {
            int id = this->GetCurrentUnixTimestamp(false);
            while (id <= this->lastId) {
                id++;
            }
            return id;
        };
        void UpdateItem(const QM::QueueItem& item);
        void UpdateItem(std::shared_ptr<QM::QueueItem> item);
        std::shared_ptr<QM::QueueItem> GetItemPtr(int id);
        /**
         * @brief Get all the items in the queue as a string formatted like:
         *
         */
        std::shared_ptr<QM::QueueItem> GetItemPtr(const QM::QueueItem& item);
        const std::map<int, std::shared_ptr<QM::QueueItem>> getList();
        std::shared_ptr<QM::QueueItem> Duplicate(std::shared_ptr<QM::QueueItem> item);
        std::shared_ptr<QM::QueueItem> Duplicate(int id);
        // @brief Update the item too then update the status. This will store the list of the generated images too
        void SetStatus(QueueStatus status, std::shared_ptr<QM::QueueItem>);
        void PauseAll();
        void RestartQueue();
        void UnPauseItem(std::shared_ptr<QM::QueueItem> item);
        void PauseItem(std::shared_ptr<QM::QueueItem> item);
        void SendEventToMainWindow(QueueEvents eventType, std::shared_ptr<QM::QueueItem> item = nullptr);
        void OnThreadMessage(wxThreadEvent& e);
        void SaveJobToFile(int id);
        void SaveJobToFile(const QM::QueueItem& item);
        bool DeleteJob(const QM::QueueItem& item);
        bool DeleteJob(int id);
        bool IsRunning();
        inline void resetRunning(std::shared_ptr<QM::QueueItem> item, const std::string& reason) {
            if (this->QueueList.empty()) {
                return;
            }
            std::lock_guard<std::mutex> lock(queueMutex);
            if (this->QueueList.find(item->id) != this->QueueList.end()) {
                item->status_message = reason;
                this->SendEventToMainWindow(QueueEvents::ITEM_FAILED, this->QueueList[item->id]);
            }
        }
        inline void resetRunning(const std::string& reason) {
            if (this->QueueList.empty()) {
                return;
            }
            std::lock_guard<std::mutex> lock(queueMutex);
            if (this->currentItem == nullptr) {
                return;
            }
            if (this->QueueList.find(this->currentItem->id) != this->QueueList.end()) {
                if (reason.empty() == false) {
                    this->currentItem->status_message = reason;
                }
                this->SendEventToMainWindow(QueueEvents::ITEM_FAILED, this->QueueList[this->currentItem->id]);
            }
        }
        inline void resetRunning(const wxString& reason) {
            if (this->QueueList.empty()) {
                return;
            }
            std::lock_guard<std::mutex> lock(queueMutex);
            if (this->currentItem == nullptr) {
                return;
            }
            if (this->QueueList.find(this->currentItem->id) != this->QueueList.end()) {
                if (reason.empty() == false) {
                    this->currentItem->status_message = reason.utf8_string();
                }
                this->SendEventToMainWindow(QueueEvents::ITEM_FAILED, this->QueueList[this->currentItem->id]);
            }
        }
        inline std::shared_ptr<QM::QueueItem> GetCurrentItem() { return this->currentItem; }

    private:
        std::mutex queueMutex;
        int GetCurrentUnixTimestamp(bool milliseconds = false);
        void LoadJobListFromDir();
        wxString jobsDir;
        int lastId    = 0;
        int lastExtId = 0;
        int GetAnId();
        // thread events handler, toupdate main window data table
        void onItemAdded(QM::QueueItem item);
        std::shared_ptr<QM::QueueItem> currentItem = nullptr;

        // @brief check if something is running or not
        bool isRunning = false;

        wxEvtHandler* eventHandler;
        wxWindow* parent;
        std::map<int, std::shared_ptr<QM::QueueItem>> QueueList;
    };
};

#endif