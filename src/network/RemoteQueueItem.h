#ifndef _NETWORK_REMOTE_QUEUE_JOB_ITEM_H_
#define _NETWORK_REMOTE_QUEUE_JOB_ITEM_H_

namespace sd_gui_utils {

    inline namespace networks {

        enum class ImageType : int {
            /// @brief The image is generated by diffusion
            GENERATED = 1 << 0,
            /// @brief The image is added by user into the controlnet
            CONTROLNET = 1 << 1,
            /// @brief This is an itial image (eg. img2img original image, or upscaler original image)
            INITIAL = 1 << 2,
            /// @brief The image is a mask image on img2img, if no MASK_USED flag, this is only a painted image without outpaint
            MASK = 1 << 3,
            /// @brief The image is a tmp image, deletable
            MOVEABLE = 1 << 4,
            /// @brief The original image, if in img2img the initial image is resized to outpaint
            ORIGINAL      = 1 << 5,
            MASK_OUTPAINT = 1 << 6,
            MASK_INPAINT  = 1 << 7,
            /// @brief This is the used mask image in the job.
            MASK_USED = 1 << 8,
            COPYABLE  = 1 << 9,
            UNKNOWN
        };

        constexpr inline ImageType operator|(ImageType lhs, ImageType rhs) {
            using T = std::underlying_type_t<ImageType>;
            return static_cast<ImageType>(static_cast<T>(lhs) | static_cast<T>(rhs));
        }
        constexpr inline ImageType& operator|=(ImageType& lhs, ImageType rhs) {
            using T = std::underlying_type_t<ImageType>;
            lhs     = static_cast<ImageType>(static_cast<T>(lhs) | static_cast<T>(rhs));
            return lhs;
        }

        inline ImageType operator&(ImageType lhs, ImageType rhs) {
            using T = std::underlying_type_t<ImageType>;
            return static_cast<ImageType>(static_cast<T>(lhs) & static_cast<T>(rhs));
        }

        namespace ImageHandleFlags {
            constexpr ImageType MOVEABLE_FLAG = (ImageType::GENERATED | ImageType::MASK_INPAINT | ImageType::MASK_OUTPAINT | ImageType::MOVEABLE);
            constexpr ImageType COPYABLE_FLAG = (ImageType::ORIGINAL | ImageType::COPYABLE);
        }

        inline bool hasImageType(ImageType combinedType, ImageType singleType) {
            using UnderlyingType = std::underlying_type_t<ImageType>;
            return (static_cast<UnderlyingType>(combinedType) & static_cast<UnderlyingType>(singleType)) != 0;
        }

        /**
         * @deprecated Use `sd_gui_utils::networks::ImageInfo` instead.
         */
        struct [[deprecated("Use `sd_gui_utils::networks::ImageInfo` instead.")]] ItemImage {
            sd_gui_utils::ImageType type = sd_gui_utils::ImageType::GENERATED;
            std::string rawData          = {};
        };

        NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(ItemImage, rawData, type)

        struct ImageInfo {
            ImageInfo(sd_gui_utils::ImageType type, std::string data_filename)
                : type(type), data_filename(data_filename) {
                  };
            ImageInfo(sd_gui_utils::ImageType type, wxString data_filename)
                : type(type), data_filename(data_filename.ToStdString()) {
                  };
            ImageInfo(sd_gui_utils::ImageType type)
                : type(type) {
            }
            ImageInfo() = default;
            // @brief The id of the job where the image is belong to
            uint64_t jobid = 0;
            // @brief The server id where the image is belong to
            std::string server_id = "";
            // @brief The image md5 hash
            std::string md5_hash                                  = "";
            [[deprecated("Use `GetId` instead.")]] std::string id = {};  // keep for compatibility
            // @brief The image width
            int width = 0;
            // @brief The image height
            int height = 0;
            // @brief The image type
            sd_gui_utils::ImageType type = sd_gui_utils::ImageType::GENERATED;
            // @brief The image size
            size_t size = 0;
            // @brief The image data
            std::string data = {};
            // @brief The image filename where it will be saved
            std::string target_filename = "";
            std::string data_filename   = "";
            std::string GetId() const {
                if (this->id.empty()) {
                    return this->md5_hash + std::to_string(this->jobid) + this->server_id;
                }
                return this->id + std::to_string(this->jobid);
            }
            inline bool convertFromNetwork(wxString tempDir = wxFileName::GetTempDir()) {
                this->target_filename = wxFileName(tempDir, wxString::Format("%" PRIu64 "%s%s.png", this->jobid, this->GetId(), this->server_id)).GetAbsolutePath().ToStdString();
                if (!wxFileExists(this->target_filename) && !this->data.empty()) {
                    return sd_gui_utils::DecodeBase64ToFile(this->data, this->target_filename);
                }
                return false;
            }
            bool operator==(const ImageInfo& rhs) const { return this->GetId() == rhs.GetId(); }
        };
        NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(ImageInfo, jobid, server_id, md5_hash, id, width, height, type, size, data, target_filename, data_filename)

        struct ModelHash {
            std::string model_hash      = "";
            std::string taesd_hash      = "";
            std::string vae_hash        = "";
            std::string esrgan_hash     = "";
            std::string controlnet_hash = "";
        };
        NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(ModelHash, model_hash, taesd_hash, vae_hash, esrgan_hash, controlnet_hash)

        struct RemoteQueueItem {
            uint64_t id = 0, created_at = 0, updated_at = 0, finished_at = 0, started_at = 0, number_of_images = 0;
            SDParams params    = SDParams();
            QueueStatus status = QueueStatus::PENDING;
            // QueueEvents event    = QueueEvents::ITEM_ADDED;
            QueueItemStats stats = QueueItemStats();
            int step = 0, steps = 0;
            size_t hash_fullsize = 0, hash_progress_size = 0;
            float time                                                = 0;
            std::string model                                         = "";
            sd_gui_utils::ModelHash hashes                            = {};
            SDMode mode                                               = SDMode::TXT2IMG;
            std::string status_message                                = "";
            uint32_t upscale_factor                                   = 4;
            std::string sha256                                        = "";
            std::string app_version                                   = SD_GUI_VERSION;
            std::string git_version                                   = GIT_HASH;
            std::string original_prompt                               = "";
            std::string original_negative_prompt                      = "";
            bool keep_checkpoint_in_memory                            = false;
            bool keep_upscaler_in_memory                              = false;
            bool need_sha256                                          = false;
            std::string generated_sha256                              = "";
            int update_index                                          = -1;
            std::string server                                        = "";
            std::vector<sd_gui_utils::networks::ImageInfo> image_info = {};
        };
        NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE_WITH_DEFAULT(RemoteQueueItem,
                                                        id,
                                                        created_at,
                                                        updated_at,
                                                        finished_at,
                                                        started_at,
                                                        params,
                                                        status,
                                                        //  event,
                                                        stats,
                                                        step,
                                                        steps,
                                                        hash_fullsize,
                                                        hash_progress_size,
                                                        time,
                                                        model,
                                                        hashes,
                                                        mode,
                                                        status_message,
                                                        upscale_factor,
                                                        sha256,
                                                        app_version,
                                                        git_version,
                                                        original_prompt,
                                                        original_negative_prompt,
                                                        keep_checkpoint_in_memory,
                                                        keep_upscaler_in_memory,
                                                        need_sha256,
                                                        generated_sha256,
                                                        update_index,
                                                        server,
                                                        image_info)
    }  // namespace networks
}  // namespace sd_gui_utils

#endif  // _NETWORK_REMOTE_QUEUE_JOB_ITEM_H_